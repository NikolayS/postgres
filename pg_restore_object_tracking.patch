From 1ad71194c9a3ca87e44d78bb773f98f4115776db Mon Sep 17 00:00:00 2001
From: Nikolay Samokhvalov <nik@postgres.ai>
Date: Fri, 23 May 2025 09:39:47 -0700
Subject: [PATCH] Enhance pg_restore to track successful and failed object
 restoration

This patch adds comprehensive object status tracking to pg_restore,
providing detailed information about which database objects were
successfully restored and which failed, including dependency analysis.

Key improvements:
- Track restoration status for each object (schema and data separately)
- Store specific error messages for failed restorations
- Provide dependency analysis showing cascading failures
- Display comprehensive restoration summary at completion
- Support both single-threaded and parallel restoration modes

The tracking uses minimal memory overhead with dynamic arrays that
grow as needed. Failed objects are tracked with their error messages,
and the summary shows which objects might be retryable after fixing
underlying dependency issues.

This enhancement helps database administrators identify specific
restoration failures and understand dependency relationships,
making it easier to diagnose and retry failed restorations.

Author: Claude (Anthropic)
---
 src/bin/pg_dump/pg_backup_archiver.c | 256 +++++++++++++++++++++++++++
 src/bin/pg_dump/pg_backup_archiver.h |  22 +++
 2 files changed, 278 insertions(+)

diff --git a/src/bin/pg_dump/pg_backup_archiver.c b/src/bin/pg_dump/pg_backup_archiver.c
index afa42337b11..e98dc8d4ee5 100644
--- a/src/bin/pg_dump/pg_backup_archiver.c
+++ b/src/bin/pg_dump/pg_backup_archiver.c
@@ -354,6 +354,9 @@ RestoreArchive(Archive *AHX, bool append_data)
 
 	AH->stage = STAGE_INITIALIZING;
 
+	/* Initialize object status tracking */
+	init_object_tracking(AH);
+
 	/*
 	 * If we're going to do parallel restore, there are some restrictions.
 	 */
@@ -810,11 +813,17 @@ RestoreArchive(Archive *AHX, bool append_data)
 	 */
 	AH->stage = STAGE_FINALIZING;
 
+	/* Print restoration summary */
+	print_restoration_summary(AH);
+
 	if (ropt->filename || ropt->compression_spec.algorithm != PG_COMPRESSION_NONE)
 		RestoreOutput(AH, sav);
 
 	if (ropt->useDB)
 		DisconnectDatabase(&AH->public);
+
+	/* Clean up object tracking */
+	cleanup_object_tracking(AH);
 }
 
 /*
@@ -883,6 +892,16 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel)
 		_printTocEntry(AH, te, TOC_PREFIX_NONE);
 		defnDumped = true;
 
+		/* Track schema restoration status */
+		if (AH->lastErrorTE == te)
+		{
+			record_object_failure(AH, te, true, "Schema creation failed");
+		}
+		else
+		{
+			record_object_success(AH, te, true);
+		}
+
 		if (strcmp(te->desc, "TABLE") == 0)
 		{
 			if (AH->lastErrorTE == te)
@@ -951,6 +970,16 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel)
 			{
 				_printTocEntry(AH, te, TOC_PREFIX_DATA);
 
+				/* Track data restoration status */
+				if (AH->lastErrorTE == te)
+				{
+					record_object_failure(AH, te, false, "Data restoration failed");
+				}
+				else
+				{
+					record_object_success(AH, te, false);
+				}
+
 				if (strcmp(te->desc, "BLOBS") == 0 ||
 					strcmp(te->desc, "BLOB COMMENTS") == 0)
 				{
@@ -1048,6 +1077,16 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel)
 			/* If we haven't already dumped the defn part, do so now */
 			pg_log_info("executing %s %s", te->desc, te->tag);
 			_printTocEntry(AH, te, TOC_PREFIX_NONE);
+
+			/* Track schema restoration status */
+			if (AH->lastErrorTE == te)
+			{
+				record_object_failure(AH, te, true, "Schema execution failed");
+			}
+			else
+			{
+				record_object_success(AH, te, true);
+			}
 		}
 	}
 
@@ -1055,8 +1094,20 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel)
 	 * If it has a statistics component that we want, then process that
 	 */
 	if ((reqs & REQ_STATS) != 0)
+	{
 		_printTocEntry(AH, te, TOC_PREFIX_STATS);
 
+		/* Track statistics restoration status */
+		if (AH->lastErrorTE == te)
+		{
+			record_object_failure(AH, te, true, "Statistics restoration failed");
+		}
+		else
+		{
+			record_object_success(AH, te, true);
+		}
+	}
+
 	/*
 	 * If we emitted anything for this TOC entry, that counts as one action
 	 * against the transaction-size limit.  Commit if it's time to.
@@ -5193,3 +5244,208 @@ DeCloneArchive(ArchiveHandle *AH)
 
 	free(AH);
 }
+
+/*
+ * Object status tracking functions
+ */
+
+/*
+ * Initialize object tracking arrays
+ */
+void
+init_object_tracking(ArchiveHandle *AH)
+{
+	AH->successful_objects = NULL;
+	AH->n_successful = 0;
+	AH->max_successful = 0;
+	AH->failed_objects = NULL;
+	AH->n_failed = 0;
+	AH->max_failed = 0;
+}
+
+/*
+ * Record successful restoration of an object
+ */
+void
+record_object_success(ArchiveHandle *AH, TocEntry *te, bool is_schema)
+{
+	/* Update object status */
+	if (is_schema)
+	{
+		te->schema_attempted = true;
+		te->schema_success = true;
+	}
+	else
+	{
+		te->data_attempted = true;
+		te->data_success = true;
+	}
+
+	/* Only add to successful list once per object */
+	if (!is_schema || !te->data_attempted || te->data_success)
+	{
+		/* Resize array if needed */
+		if (AH->n_successful >= AH->max_successful)
+		{
+			AH->max_successful = AH->max_successful ? AH->max_successful * 2 : 100;
+			AH->successful_objects = (TocEntry **) pg_realloc(AH->successful_objects,
+															 AH->max_successful * sizeof(TocEntry *));
+		}
+
+		/* Check if already in successful list */
+		for (int i = 0; i < AH->n_successful; i++)
+		{
+			if (AH->successful_objects[i] == te)
+				return;
+		}
+
+		AH->successful_objects[AH->n_successful++] = te;
+	}
+}
+
+/*
+ * Record failed restoration of an object
+ */
+void
+record_object_failure(ArchiveHandle *AH, TocEntry *te, bool is_schema, const char *error_msg)
+{
+	/* Update object status */
+	if (is_schema)
+	{
+		te->schema_attempted = true;
+		te->schema_success = false;
+	}
+	else
+	{
+		te->data_attempted = true;
+		te->data_success = false;
+	}
+
+	/* Store error message */
+	if (error_msg && !te->failure_reason)
+		te->failure_reason = pg_strdup(error_msg);
+
+	/* Resize array if needed */
+	if (AH->n_failed >= AH->max_failed)
+	{
+		AH->max_failed = AH->max_failed ? AH->max_failed * 2 : 100;
+		AH->failed_objects = (TocEntry **) pg_realloc(AH->failed_objects,
+													   AH->max_failed * sizeof(TocEntry *));
+	}
+
+	/* Check if already in failed list */
+	for (int i = 0; i < AH->n_failed; i++)
+	{
+		if (AH->failed_objects[i] == te)
+			return;
+	}
+
+	AH->failed_objects[AH->n_failed++] = te;
+}
+
+/*
+ * Print restoration summary showing successful and failed objects
+ */
+void
+print_restoration_summary(ArchiveHandle *AH)
+{
+	int			i;
+
+	pg_log_info("Restoration Summary:");
+	pg_log_info("===================");
+	pg_log_info("Successfully restored objects: %d", AH->n_successful);
+	pg_log_info("Failed objects: %d", AH->n_failed);
+
+	if (AH->n_failed > 0)
+	{
+		pg_log_info("");
+		pg_log_info("Failed Objects (including dependency failures):");
+		for (i = 0; i < AH->n_failed; i++)
+		{
+			TocEntry   *te = AH->failed_objects[i];
+			const char *reason = te->failure_reason ? te->failure_reason : "unknown error";
+
+			if (te->namespace)
+				pg_log_info("  %s \"%s.%s\": %s", te->desc, te->namespace, te->tag, reason);
+			else
+				pg_log_info("  %s \"%s\": %s", te->desc, te->tag, reason);
+		}
+
+		pg_log_info("");
+		pg_log_info("Objects that might need retry due to dependencies:");
+		for (i = 0; i < AH->n_failed; i++)
+		{
+			TocEntry   *te = AH->failed_objects[i];
+			int			j;
+
+			/* Check if this object has dependents that also failed */
+			for (j = 0; j < te->nRevDeps; j++)
+			{
+				TocEntry   *dep_te = AH->tocsByDumpId[te->revDeps[j]];
+
+				if (dep_te != NULL)
+				{
+					bool		dep_failed = false;
+
+					/* Check if dependent also failed */
+					for (int k = 0; k < AH->n_failed; k++)
+					{
+						if (AH->failed_objects[k] == dep_te)
+						{
+							dep_failed = true;
+							break;
+						}
+					}
+
+					if (dep_failed)
+					{
+						if (dep_te->namespace)
+							pg_log_info("  %s \"%s.%s\" depends on failed %s \"%s.%s\"",
+										dep_te->desc, dep_te->namespace, dep_te->tag,
+										te->desc, te->namespace ? te->namespace : "", te->tag);
+						else
+							pg_log_info("  %s \"%s\" depends on failed %s \"%s\"",
+										dep_te->desc, dep_te->tag,
+										te->desc, te->tag);
+					}
+				}
+			}
+		}
+	}
+}
+
+/*
+ * Clean up object tracking memory
+ */
+void
+cleanup_object_tracking(ArchiveHandle *AH)
+{
+	TocEntry   *te;
+
+	/* Free failure reason strings */
+	for (te = AH->toc->next; te != AH->toc; te = te->next)
+	{
+		if (te->failure_reason)
+		{
+			free(te->failure_reason);
+			te->failure_reason = NULL;
+		}
+	}
+
+	/* Free tracking arrays */
+	if (AH->successful_objects)
+	{
+		free(AH->successful_objects);
+		AH->successful_objects = NULL;
+	}
+	if (AH->failed_objects)
+	{
+		free(AH->failed_objects);
+		AH->failed_objects = NULL;
+	}
+
+	AH->n_successful = 0;
+	AH->max_successful = 0;
+	AH->n_failed = 0;
+	AH->max_failed = 0;
+}
diff --git a/src/bin/pg_dump/pg_backup_archiver.h b/src/bin/pg_dump/pg_backup_archiver.h
index 365073b3eae..dcbff9a3e50 100644
--- a/src/bin/pg_dump/pg_backup_archiver.h
+++ b/src/bin/pg_dump/pg_backup_archiver.h
@@ -339,6 +339,14 @@ struct _archiveHandle
 	RestorePass restorePass;	/* used only during parallel restore */
 	struct _tocEntry *currentTE;
 	struct _tocEntry *lastErrorTE;
+
+	/* object status tracking */
+	struct _tocEntry **successful_objects;	/* array of successfully restored objects */
+	int			n_successful;				/* count of successful objects */
+	int			max_successful;				/* allocated size of successful_objects array */
+	struct _tocEntry **failed_objects;		/* array of failed objects */
+	int			n_failed;					/* count of failed objects */
+	int			max_failed;					/* allocated size of failed_objects array */
 };
 
 
@@ -382,6 +390,13 @@ struct _tocEntry
 								 * (REQ_* bit mask) */
 	bool		created;		/* set for DATA member if TABLE was created */
 
+	/* restoration status tracking */
+	bool		schema_attempted;	/* true if schema restoration was attempted */
+	bool		schema_success;		/* true if schema restoration succeeded */
+	bool		data_attempted;		/* true if data restoration was attempted */
+	bool		data_success;		/* true if data restoration succeeded */
+	char	   *failure_reason;		/* error message if restoration failed */
+
 	/* working state (needed only for parallel restore) */
 	struct _tocEntry *pending_prev; /* list links for pending-items list; */
 	struct _tocEntry *pending_next; /* NULL if not in that list */
@@ -398,6 +413,13 @@ extern void replace_on_exit_close_archive(Archive *AHX);
 
 extern void warn_or_exit_horribly(ArchiveHandle *AH, const char *fmt,...) pg_attribute_printf(2, 3);
 
+/* Object status tracking functions */
+extern void init_object_tracking(ArchiveHandle *AH);
+extern void record_object_success(ArchiveHandle *AH, TocEntry *te, bool is_schema);
+extern void record_object_failure(ArchiveHandle *AH, TocEntry *te, bool is_schema, const char *error_msg);
+extern void print_restoration_summary(ArchiveHandle *AH);
+extern void cleanup_object_tracking(ArchiveHandle *AH);
+
 /* Options for ArchiveEntry */
 typedef struct _archiveOpts
 {
-- 
2.43.0

